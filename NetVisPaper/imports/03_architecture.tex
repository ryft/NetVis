NetViz is a Java application which uses OpenGL to draw visualizations and Swing for providing a graphical user interface to display further information and allow the user to customise the visualizations.

In designing the application, we have focused on maintaining extensability and keeping a modular programming style. It is simple to add support for additional input data formats, or to develop a new visualisation that utilises the same data processing engine.

Packet data is given to the application as a CSV packet capture file as it can be obtained, for instance, by exporting from Wireshark. NetViz will process each packet and analyse its fields Source IP, MAC Address, Port, Destination IP, MAC Address, Port, Protocol, and size of its data. Note that in this stage the application does not process the content of packets, and instead looks at the structure of the packets.

A convenient feature of the data input system is a time control system. The CSV file is processed as if its packets were coming in in real time. The user can choose to speed up or slow down the speed with which packets are fed into the application, can pause processing, or skip towards the end of the data record. This is very helpful in analysing the data since critical time intervals can be analysed in more detail.

The application is set up in such a way that it is also easy to use the activity of a live network as its input source.

The input data is processed in a data controller which supplies the visualizations and the user interface with packet data. If the user has chosen to apply filters to the data, the data controller only directs the filtered data stream to the rest of the application, so that all parts share a common data source.

\includegraphics[width=\linewidth]{materials/architecture.jpg}

\textbf{High-level: What do filters do?}
The application supports two types of filters - filters that the user explicitly defines, and filters applied on-the-fly from within the visualisations.
Both types are applied to all visualisations and information displayed, and can be adjusted at any time without losing prior data.
The user has access to a variety of different filter controls.  First, there is a menu for filtering by transit protocol. By default, all protocols are selected and therefore included. Protolcols are sorted into menus by protocol family, appearing in multiple places where appropriate. Second, there is a control to select the range of ports the application uses, which defaults to the maximum port range.  The source and destination ports can be set separately, enabling a user to view all data entering/exiting a port as desired.  Next, there are IP and MAC address filters.  These work on a blacklist/whitelist system, allowing a user to only view packets to or from a particular set of addresses, or ignore packets going to or from a different set.  This enables a user to, for instance, ignore traffic from sources they know are irrelevant or focus only on an address that is causing concern.
The second type of filter will be dealt with in more detail in sections 4.2 and 4.3.

\cite{stevens1946theory} developed an influential classification of data types into nominal, ordinal, interval, and ratio types. The packet attributes that NetVis processes fall into different of these types. It is, however, desirable to map some of these properties into a shared representation which allows a more intuitive grasp of the distribution of attributes. We achieve this by processing the packets in a `normalising' system. This system keeps track of the used values and maps them into the interval $[0,1]$. In this way all normalised packets can be displayed in relation to a number axis. This representation is used in three different visualizations.

Each normaliser in the system is able to create a temporary filter in the application that will filter its corresponding attribute on a certain range.
Since the normalising class is in control of its filter it creates a zooming effect based on the range of the filter: the lower bound is normalised to 0, the upper bound to 1. 


%Modularity: \textbf{[Make this better.]}
%The application was designed to be very extensible.  Adding a new visualisation is simply a matter of adding it to the application's list of those available, which will cause it to be included and kept up-to-date as packets come in and are filtered.  The same is true for filters and normalisers.  \textbf{[wrong place:] }Adding a filter would result in its controls automatically being included in the right panel and all packets would then be filtered according to the criteria it specifies.  Adding a normaliser would cause it to be integrated with the Spinning Cube, Dataflow and Attribute Distribution visualisations.  Ths modularity extends even so far as data input.  If a class were written to accept packets from a different source, it would be trivial to switch the application to use this class.